#!/opt/local/bin/perl

use 5.006001;
use strict;
use warnings;

use Carp qw< confess >;

use Getopt::Long;

use File::Next ();
use PPI::Document ();
use PPI::Document::File ();
use PPI::Dumper ();

exit main();

sub main {
    my $opts = {
        minfiles   => 1,
        minfound   => 2,
        minlen     => 1,
        exclude_re => [],
        include_re => [],
    };
    GetOptions(
        's|strings'    => \$opts->{strings},
        'c|code'       => \$opts->{code},
        'minfiles=i'   => \$opts->{minfiles},
        'minfound=i'   => \$opts->{minfound},
        'minlen=i'     => \$opts->{minlen},
        'exclude_re=s' => $opts->{exclude_re},
        'include_re=s' => $opts->{include_re},
    ) or exit 1;

    die 'Must specify at least --code or --strings' unless $opts->{code} || $opts->{strings};

    for ( @{$opts->{exclude_re}}, @{$opts->{include_re}} ) {
        $_ = qr/$_/;
    }

    my @files = build_file_list( @ARGV );

    warn scalar @files, " files to scan\n";

    my $pcpd = App::PCPD->new( $opts );
    for my $filename ( @files ) {
        print "$filename\n";
        my $doc = PPI::Document->new( $filename );
        #my $dumper = PPI::Dumper->new( $doc, whitespace => 0, locations => 0 );
        #$dumper->print;
        if ( $pcpd->opts->{strings} ) {
            $pcpd->watch_for_strings( $filename, $doc );
        }
        if ( $pcpd->opts->{code} ) {
            $pcpd->watch_for_code( $filename, $doc );
        }
    }

    if ( $pcpd->opts->{strings} ) {
        $pcpd->print_strings_results( $opts );
    }

    return 0;
}


sub build_file_list {
    my @starts = @_;

    my %files;

    for my $start ( @starts ) {
        if ( -d $start ) {
            my @non_descend = qw( CVS .svn .git blib );
            my %non_descend = map { ( $_ => 1 ) } @non_descend;
            my $descend_filter = sub { !$non_descend{$_} };
            my $file_filter    = sub { /\.(pl|pm)$/ };
            my $iter = File::Next::files( {
                    descend_filter  => $descend_filter,
                    file_filter     => $file_filter,
                    follow_symlinks => 0,
                }, $start );
            while ( my $file = $iter->() ) {
                ++$files{$file};
            }
        }
        else {
            ++$files{$start};
        }
    }

    my @files = sort keys %files;

    return @files;
}


package App::PCPD;

sub new {
    my $class = shift;
    my $opts  = shift;

    my $self = bless {
        opts    => $opts,
        strings => {},
        code    => {},
    }, $class;

    return $self;
}

sub opts {
    my $self = shift;

    return $self->{opts};
}

sub add_strings {
    my $self     = shift;
    my $filename = shift;
    my $element  = shift;
    my @strings  = shift;

    for my $string ( @strings ) {
        $string =~ s/^\s+//;
        $string =~ s/\s+$//;

        my $strobj = ($self->{strings}->{$string} ||= App::PCPD::String->new( $string ));
        $strobj->add_instance( $filename, $element->line_number );
    }
}


sub watch_for_strings {
    my $self     = shift;
    my $filename = shift;
    my $el       = shift;

    my $str;
    if ( $el->isa( 'PPI::Token::Quote' ) ) {
        $str = $el->string;

        # Maybe?
        if ( $el->isa( 'PPI::Token::Quote::Double' ) || $el->isa( 'PPI::Token::Quote::Interpolate' ) ) {
            $str =~ s/\\n/\n/g;
        }
    }

    #elsif ( $el->isa( 'PPI::Token::HereDoc' ) ) {
    #    $str = $el->heredoc;
    #}

    if ( defined($str) && (length($str) >= $self->opts->{minlen}) ) {
        my $ignore = 0;
        for my $re ( @{$self->opts->{exclude_re}} ) {
            if ( $str =~ $re ) {
                $ignore = 1;
                last;
            }
        }

        my $include = !$ignore;
        if ( $include && @{$self->opts->{include_re}} ) {
            $include = 0;
            for my $re ( @{$self->opts->{include_re}} ) {
                if ( $str =~ $re ) {
                    $include = 1;
                    last;
                }
            }
        }

        $self->add_strings( $filename, $el, $str ) if $include;
    }

    if ( $el->isa('PPI::Node') ) {
        foreach my $child ( @{$el->{children}} ) {
            $self->watch_for_strings( $filename, $child );
        }
    }

    return;
}

sub watch_for_code {
    my $self     = shift;
    my $filename = shift;
    my $el       = shift;

    if ( $el->isa( 'PPI::Statement' ) && !$el->isa( 'PPI::Statement::Expression' ) ) {
        $self->add_code( $filename, $el );
    }

    if ( $el->isa('PPI::Node') ) {
        foreach my $child ( @{$el->{children}} ) {
            $self->watch_for_code( $filename, $child );
        }
    }

    return;
}

sub add_code {
    my $self     = shift;
    my $filename = shift;
    my $element  = shift;

    my $code = $element->content;

    my $codeobj = ($self->{code}->{$code} ||= App::PCPD::Code->new( $code ));
    $codeobj->add_instance( $filename, $element->line_number );
}


sub print_strings_results {
    my $self = shift;

    for my $str ( $self->ordered_strings ) {
        my $strobj = $self->{strings}->{$str};

        my $show = 1;
        $show &&= !$self->opts->{minfound} || ($strobj->nfound >= $self->opts->{minfound});
        $show &&= !$self->opts->{minfiles} || ($strobj->nfiles >= $self->opts->{minfiles});

        if ( $show ) {
            print "$str\n";
            my $instances = $strobj->instances;
            for my $file ( sort keys %{$instances} ) {
                my $n = +@{$instances->{$file}};
                printf( "%5d %s\n", $n, $file );
            }
            print "\n";
        }
    }

    return;
}


sub ordered_strings {
    my $self = shift;

    my @strings = keys %{$self->{strings}};

    @strings = sort { lc($a) cmp lc($b) } @strings;

    return @strings;
}


package App::PCPD::String;

sub new {
    my $class = shift;
    my $str   = shift;

    my $self = bless {
        str       => $str,
        nfound    => 0,
        instances => {},
    }, $class;

    return $self;
}

sub add_instance {
    my $self     = shift;
    my $filename = shift;
    my $lineno   = shift;

    ++$self->{nfound};
    push( @{$self->{instances}->{$filename}}, $lineno );

    return;
}

sub nfound {
    my $self = shift;

    return $self->{nfound};
}

sub nfiles {
    my $self = shift;

    return scalar keys %{$self->{instances}};
}

sub instances {
    my $self = shift;

    return $self->{instances};
}

package App::PCPD::Code;

sub new {
    my $class = shift;
    my $code  = shift;

    my $self = bless {
        code      => $code,
        nfound    => 0,
        instances => {},
    }, $class;

    return $self;
}

sub add_instance {
    my $self     = shift;
    my $filename = shift;
    my $lineno   = shift;

    ++$self->{nfound};
    push( @{$self->{instances}->{$filename}}, $lineno );

    return;
}

sub nfound {
    my $self = shift;

    return $self->{nfound};
}

sub nfiles {
    my $self = shift;

    return scalar keys %{$self->{instances}};
}

sub instances {
    my $self = shift;

    return $self->{instances};
}

1;
