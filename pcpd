#!/opt/local/bin/perl

use 5.006001;
use strict;
use warnings;

use Carp qw< confess >;

use Getopt::Long;

use File::Next ();
use PPI::Document ();
use PPI::Document::File ();

exit main();

sub main {
    my $opts = {
        minfiles => 1,
        minfound => 2,
        minlen   => 1,
    };
    GetOptions(
        'minfiles=i' => \$opts->{minfiles},
        'minfound=i' => \$opts->{minfound},
        'minlen=i'   => \$opts->{minlen},
    ) or exit 1;

    my $iter = build_file_iterator( @ARGV );

    my $pcpd = App::PCPD->new;
    while ( my $filename = $iter->() ) {
        print "$filename\n";
        my $doc = PPI::Document->new( $filename );
        #my $dumper = PPI::Dumper->new( $doc, whitespace => 0, locations => 0 );
        $pcpd->watch_for_strings( $filename, $doc, $opts );
    }

    $pcpd->print_results( $opts );

    return 0;
}


sub build_file_iterator {
    my @starts = @_;

    my @non_descend = qw( CVS .svn .git blib );
    my %non_descend = map { ( $_ => 1 ) } @non_descend;
    my $descend_filter = sub { !$non_descend{$_} };
    my $file_filter    = sub { /\.(pl|pm)$/ };
    my $iter = File::Next::files( {
            descend_filter  => $descend_filter,
            file_filter     => $file_filter,
            follow_symlinks => 0,
        }, @starts );

    return $iter;
}


package App::PCPD;

sub new {
    my $class = shift;

    my $self = bless {
        strings => {},
    }, $class;

    return $self;
}

sub add_strings {
    my $self     = shift;
    my $filename = shift;
    my $element  = shift;
    my @strings  = shift;

    for my $string ( @strings ) {
        $string =~ s/^\s+//;
        $string =~ s/\s+$//;

        my $strobj = ($self->{strings}->{$string} ||= App::PCPD::String->new( $string ));
        $strobj->add_instance( $filename, $element->line_number );
    }
}


sub watch_for_strings {
    my $self     = shift;
    my $filename = shift;
    my $el       = shift;
    my $opts     = shift;

    my $str;
    if ( $el->isa( 'PPI::Token::Quote' ) ) {
        $str = $el->string;
    }
    #elsif ( $el->isa( 'PPI::Token::HereDoc' ) ) {
    #    $str = $el->heredoc;
    #}

    if ( $str && (length($str) >= $opts->{minlen}) ) {
        $self->add_strings( $filename, $el, $str );
    }

    if ( $el->isa('PPI::Node') ) {
        foreach my $child ( @{$el->{children}} ) {
            $self->watch_for_strings( $filename, $child, $opts );
        }
    }

    return;
}

sub print_results {
    my $self = shift;
    my $opts = shift;

    for my $str ( sort keys %{$self->{strings}} ) {
        my $strobj = $self->{strings}->{$str};

        my $show = 1;
        $show &&= !$opts->{minfound} || ($strobj->nfound >= $opts->{minfound});
        $show &&= !$opts->{minfiles} || ($strobj->nfiles >= $opts->{minfiles});

        if ( $show ) {
            print "$str\n";
            my $instances = $strobj->instances;
            for my $file ( sort keys %{$instances} ) {
                my $n = +@{$instances->{$file}};
                printf( "%5d %s\n", $n, $file );
            }
            print "\n";
        }
    }

    return;
}


package App::PCPD::String;

sub new {
    my $class = shift;
    my $str   = shift;

    my $self = bless {
        str       => $str,
        nfound    => 0,
        instances => {},
    }, $class;

    return $self;
}

sub add_instance {
    my $self     = shift;
    my $filename = shift;
    my $lineno   = shift;

    ++$self->{nfound};
    push( @{$self->{instances}->{$filename}}, $lineno );

    return;
}

sub nfound {
    my $self = shift;

    return $self->{nfound};
}

sub nfiles {
    my $self = shift;

    return scalar keys %{$self->{instances}};
}

sub instances {
    my $self = shift;

    return $self->{instances};
}

1;
