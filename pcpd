#!/opt/local/bin/perl

## There's too much use of source code in strings.
## no critic (RequireInterpolationOfMetachars)

use 5.006001;
use strict;
use warnings;

use Carp qw< confess >;

use File::Slurp qw( read_file );
use PPI::Document ();
use PPI::Document::File ();
use PPI::Dumper ();
use Perl::Critic::Document ();

#-----------------------------------------------------------------------------

our $VERSION = '1.121';

#-----------------------------------------------------------------------------

@ARGV = '/Users/andy/bin/ack';
exit main();

sub main {
    my $pcpd = App::PCPD->new;
    for my $filename ( @ARGV ) {
        my $doc = PPI::Document->new( $filename );
        my $dumper = PPI::Dumper->new( $doc, whitespace => 0, locations => 0 );
        $pcpd->watch_for_strings( $filename, $doc );
    }
    {use Data::Dumper; local $Data::Dumper::Sortkeys=1; warn Dumper( $pcpd->{strings} )}

    return 0;
}

my $single_quoted_str = 'Quoted string';
sub some_func {
    my $double_quoted_str = "Quoted string";
    my $heredoc = <<'HERE';
    String in a heredoc
HERE
}

package App::PCPD;

sub new {
    my $class = shift;

    my $self = bless {
        strings => [],
    }, $class;

    return $self;
}

sub add_strings {
    my $self     = shift;
    my $filename = shift;
    my $element  = shift;
    my @strings  = shift;

    my @trimmed = @strings;
    for ( @trimmed ) {
        s/^\s+//;
        s/\s+$//;
    }
    push( @{$self->{strings}}, map { [ $filename, $element, $_ ] } @trimmed );
}


sub watch_for_strings {
    my $self     = shift;
    my $filename = shift;
    my $el       = shift;

    if ( $el->isa( 'PPI::Token::Quote' ) ) {
        $self->add_strings( $filename, $el, $el->string );
    }
    elsif ( $el->isa( 'PPI::Token::HereDoc' ) ) {
        $self->add_strings( $filename, $el, $el->heredoc );
    }

    if ( $el->isa('PPI::Node') ) {
        foreach my $child ( @{$el->{children}} ) {
            $self->watch_for_strings( $filename, $child );
        }
    }

    return;
}

